**PROJECT GOAL: ASCII Converter Bug Fix & Optimization**
The primary goal is to fix the "vertical stretching" (squashed aspect ratio) issue and implement optimizations for perfect, adaptive, multiplatform ASCII art output. The codebase is currently written in **C** and uses **stb_image.h** for loading images/GIFs. The solution should maintain the C core while leveraging C++ where necessary (**Hybrid C/C++**).

---

### 1. CRITICAL BUG FIX: ASPECT RATIO CORRECTION

The current ASCII output is vertically stretched because the terminal character ratio (â‰ˆ 1:2) is not compensated for in the image resize logic (currently using â‰ˆ 2:1 ratio, e.g., `100 columns Ã— 50 rows`).

**REQUIRED ACTION:** Adjust the image resize target to a **4:1 (Width:Height)** ratio to achieve proportional output across all OS terminals (Windows, Linux, macOS).

| Preset Flag | Current Resize Target (W Ã— H) | Corrected Resize Target (W Ã— H) | Implementation Detail                |
| ----------- | ----------------------------- | ------------------------------- | ------------------------------------ |
| `-D 3`      | 100 Ã— 50                      | 100 Ã— 25                        | New Height = Old Height / 2          |
| `-D N`      | W Ã— H                         | W Ã— âŒŠH / 2âŒ‹                     | Use integer floor for the new height |

**Location of Fix:** Locate the function responsible for determining the output dimensions based on the `-D` flag or before calling the `stbi_load` / frame processing functions. Apply the **H / 2** adjustment to the target height before passing it to the image scaling routine.

---

### 2. ADAPTIVE TERMINAL SIZING (Multiplatform Support)

Implement dynamic size detection so the ASCII art automatically fits the user's terminal window.

**REQUIRED ACTION:** When no size flag (`-D`) is provided, or an explicit `--auto` flag is used, the program must detect the current terminal dimensions.

| Language            | Terminal Size Function                |
| ------------------- | ------------------------------------- |
| C/C++ (Linux/macOS) | `ioctl(STDOUT_FILENO, TIOCGWINSZ, â€¦)` |
| C/C++ (Windows)     | `GetConsoleScreenBufferInfo()`        |

**Implementation Flow:**

1. Get Terminal Width ((W_t)) and Terminal Height ((H_t)) in characters.
2. Calculate Target ASCII Width ((W_{ascii})) and Target ASCII Height ((H_{ascii})).
3. Apply the **4:1 aspect ratio correction** to ensure the image remains proportional within the available space.

**Fit Algorithm:** Calculate the scaling factor based on the smallest fit to prevent scrolling:
[ \text{Target Width} = W_t ]
[ \text{Target Height} = \lfloor \frac{W_t}{4} \rfloor ]

(This simple method scales based on width while preserving the correct ratio.)

---

### 3. QUALITY OPTIMIZATION & HYBRID INTEGRATION

Improve the visual quality of the ASCII mapping and safely adopt C++ features.

**REQUIRED ACTION:** Ensure the best quality conversion and a smooth C/C++ integration path.

#### A. ASCII Palette & Luminance

* **Refine Palette:** Use a dense, ordered character palette for higher detail:
  `$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/|()1{}[]?-_+~<>i!lI;:,.'^ `
* **Accurate Grayscale:** Use a standard luminance formula (e.g., *ITU-R BT.601*) when converting RGB to brightness instead of a simple average:
  [ \text{Luminance} = 0.299R + 0.587G + 0.114B ]

#### B. Hybrid C/C++ Structure

* **Compiler:** Change the build system to use `g++` (or `clang++`) for all compilation and linking.
* **stb_image.h:** No changes required â€” continue using it to load image data.
* **New C++ Module:** Create a new file `ascii_processor.cpp` to handle advanced resize and luminance calculations. This enables future-proofing (e.g., OpenCV or live webcam support).
* **C/C++ Interface:** Wrap any functions in the C++ module that need to be called by your existing C code with `extern "C"` in the header file (`ascii_processor.h`) to ensure proper linking.

```cpp
#ifdef __cplusplus
extern "C" {
#endif

// Function to be called from C code
void process_frame_optimized(unsigned char *data, int width, int height);

#ifdef __cplusplus
}
#endif
```

---

# ASCII-MEDIA â€” Tekstual Blueprint Lengkap (Tanpa Struktur File)

Dokumen ini adalah *blueprint* teks penuh dan mendetail untuk menggabungkan sebuah project konverter ASCII berbasis C (gambar/GIF) dengan project player/streamer berbasis Rust (webcam/video). Dokumen hanya berfokus pada konsep, API, alur data, best practices, pencegahan bug, build logic secara umum, dan praktik pengujian â€” tanpa mengasumsikan struktur folder atau file asli.

Tujuan: hasil akhir adalah satu binary native stabil (tidak crash), aman dari memory-safety issues, mudah diuji, dan mudah dibuild di Replit / Linux / Windows.

---

## 1. Ringkasan Arsitektur (Teks)

* **Input layer (Rust):** menangani CLI, validasi input, capture webcam/video stream, sinkronisasi audio (opsional), dan pengaturan pipeline (FPS, mode). Rust bertugas mengatur lifecycle, menolak input invalid, dan menjaga keselamatan memori.

* **Processing layer (C / C++):** menerima frame mentah (RGB/RGBA/GRAY) melalui FFI, melakukan decoding (jika diperlukan), preprocessing (resize, blur optional), konversi luminance â†’ indeks palet karakter, postprocessing (smoothing, braille, color mapping). Hasil akhir adalah buffer/char* yang siap ditampilkan.

* **Render layer (Rust):** menerima pointer ke ASCII text (atau string), menampilkannya di terminal (menggunakan direct stdout, termios/ncurses, atau library terminal Rust), mengelola refresh, dan mengembalikan control ke pipeline.

* **Build & Orchestration:** Gunakan Cargo untuk orkestrasi build; compile kode C/C++ menjadi library statis saat `cargo build` (via `cc` atau `cmake` dalam `build.rs`). Link ke binary Rust utama jadi satu executable.

---

## 2. Prinsip- Prinsip Keselamatan & Pencegahan Error

1. **Boundary Safety (FFI):** setiap fungsi yang diekspos harus memakai kontrak jelas: parameter pointer + panjang buffer + return status. Contoh C-style signature untuk frameâ†’ascii:

   ```c
   // returns 0 on success, non-zero on error
   int convert_frame_to_ascii(const uint8_t* rgba, int width, int height,
                              char** out_ascii, int* out_len);

   // caller harus memanggil free_ascii(out_ascii) setelah selesai
   void free_ascii(char* ptr);
   ```

   * Jangan kembalikan heap-allocated pointer tanpa fungsi `free` yang jelas.
   * Gunakan `int` atau enum untuk kode error (no exceptions across FFI).

2. **Ownership Contract di Rust:** selalu gunakan `CString`/`CStr` dan `Vec<u8>` untuk data buffer. Gunakan `unsafe` hanya di blok kecil dan bungkus dalam fungsi aman (`safe wrapper`). Contoh wrapper:

   ```rust
   pub fn convert_frame(rgba: &[u8], w: i32, h: i32) -> Result<String, MyError> {
       // validate length: rgba.len() == (w*h*4)
       // call unsafe FFI convert_frame_to_ascii
   }
   ```

3. **No Cross-Allocator Freeing:** alokasi harus dibebaskan oleh alocator yang sama. Jika C mengalokasi `char*` maka harus ada `free_ascii(char*)` di C untuk dipanggil dari Rust. Jangan memanggil `free()` di Rust untuk pointer yang dialokasikan di C.

4. **Defensive Input Validation:** selalu periksa null pointer, width/height > 0, buffer length minimum, dan file existence sebelum memproses.

5. **Errors, Logging, and Recovery:** gunakan sistem error yang konsisten. Di Rust gunakan `anyhow`/`thiserror` dengan `Result`. Di C return kode error integer; log via `stderr` dan opsi verbose.

6. **Thread Safety & Concurrency:**

   * C/C++ code must be reentrant or protected by mutexes if stateful.
   * Prefer stateless conversion functions that take input buffer and return new output.
   * Rust side should use channels (crossbeam) or `std::sync` primitives. Use bounded channels to avoid unbounded memory growth.

7. **Fail-safe Modes:** jika conversion gagal, pipeline harus fallback to safe placeholder (e.g., a low-res ASCII "frame unavailable") instead of crashing. Log error, skip frame, and continue.

---

## 3. API Contracts (Teks Lengkap)

### A. C/C++ conversion API (FFI-friendly)

* `int convert_frame_to_ascii(const uint8_t* rgba, int width, int height, char** out_ascii, int* out_len);`

  * **Behavior:** Convert RGBA frame to a NUL-terminated ASCII buffer. Allocate buffer with `malloc` and set `*out_ascii` pointer and `*out_len` (bytes). Return 0 success, non-zero error code.

* `void free_ascii(char* ptr);`

  * **Behavior:** Free memory allocated by `convert_frame_to_ascii`.

* `int convert_image_file_to_ascii(const char* path, char** out_ascii, int* out_len);`

  * **Behavior:** Load image (via stb) and convert to ascii string.

* Error code enums (C):

  * `0` = OK
  * `1` = INVALID_ARG
  * `2` = DECODE_ERROR
  * `3` = OOM
  * `4` = UNSUPPORTED_FORMAT

### B. Rust-side safe wrapper (pseudocode)

* `fn convert_frame_safe(rgba: &[u8], w: i32, h: i32) -> Result<String, MyError>`

  * Validate input length (w*h*4), call unsafe FFI function, convert returned `*char` into `String` (using `CStr::from_ptr`), call `free_ascii`, return `String`.

* `fn convert_file_safe(path: &Path) -> Result<String, MyError>`

* All wrappers must catch error codes and map to Rust `Error` types, not `panic!`.

---

## 4. Frame Flow, Buffering, and FPS Control 

1. **Capture Loop (Rust):** capture frame, push to bounded channel (capacity N, e.g., 2). If channel full and `allow_frame_skip` true â†’ drop oldest/newest per policy.

2. **Worker Pool (C++ optional):** spawn a small pool of worker threads (2â€“4) that receive frames, convert via `convert_frame_to_ascii`, then send result back to render queue.

3. **Render Loop (Rust):** receive ascii string, print to terminal. Use `[H` (cursor home) and avoid full terminal clear to reduce flicker. Respect requested FPS by sleeping between frames using `std::thread::sleep`, but prioritize real-time by measuring actual elapsed time.

4. **Backpressure strategy:** use bounded channels + drop policy. Never allow unbounded memory queue.

---

## 5. Build Strategy 

* Use Rust `build.rs` with `cc` crate or `cmake` crate to compile native C/C++ code during `cargo build`.
* Ensure build script sets `cargo:rustc-link-lib` and `cargo:rustc-link-search` correctly.
* Treat warnings as errors in CI to prevent regressions (`-Werror` for gcc/clang) but keep local dev flexible if needed.
* For Windows: ensure MSVC vs GNU toolchain differences are addressed (provide msbuild/cmake options). Offer preprocessor guards to exclude POSIX-only features.

Example build sequence (abstract):

1. `cargo build --release` triggers `build.rs` which compiles C/C++ into static lib and places it in `OUT_DIR`.
2. Rust links lib and produces single binary.

---

## 6. Testing & CI 

1. **Unit tests (C/C++):** small harness executable that calls conversion APIs with controlled inputs (tiny images, edge cases: 1x1, invalid pointer, truncated buffer). Use ASAN/UBSAN in CI to detect UB.

2. **Unit tests (Rust):** test wrappers against known PNG/JPEG samples; mock FFI failures using test doubles.

3. **Integration tests:** simulate capture â†’ convert â†’ render pipeline. Use recorded video files to ensure deterministic results.

4. **Fuzzing & Memory safety:** run libFuzzer / AFL on C converter to find crashes. Run ASAN builds in CI.

5. **CI pipeline (GitHub Actions suggested):**

   * Matrix build for Linux (gcc), macOS (clang), Windows (MSVC)
   * Steps: install deps, build release with `cargo build --release`, run unit tests, run integration smoke tests, run ASAN build fallback.

---


---

## 7. Performance Considerations (Text)

* Use small worker pool; avoid spawning thread per frame.
* Use SIMD-friendly image ops in C/C++ where possible (libjpeg, NEON/SSE) â€” optional optimization.
* Resize early in pipeline to target ASCII resolution to reduce per-pixel work.
* Keep ASCII palette mapping table in memory; avoid recomputing luminance->index formula per char if possible (precompute lookup table for 0..255).

---

## 8. CLI & UX 

Recommended flags (textual description):

* `--input <path|url|webcam>`: accepts filename, URL, or `camera:0` style identifier.
* `--width <cols>` and `--height <rows>` or `--auto` to detect terminal size.
* `--fps <value>`: target framerate.
* `--ratio <float>`: terminal character height/width ratio correction.
* `--palette <string>`: custom character palette.
* `--safe-mode`: disable threading for debugging.
* `--verbose` and `--log-file <path>`.

Error reporting should be user-friendly with suggestions (e.g., "Cannot open webcam: check permissions or device ID").

---

## 9. Recovery & Robustness 

* **Recover from decode failures:** if a frame fails to convert, log error and show placeholder frame.
* **Graceful shutdown:** on Ctrl+C or fatal error, join threads cleanly, free outstanding buffers via `free_ascii`, and flush logs.
* **Resource limits:** set max memory budget for queues and per-frame buffer size; fail gracefully if exceeded.

---

## 10. Recommended Libraries & Tools 

* **Rust side:** `opencv` crate (optional), `anyhow`, `thiserror`, `clap`, `crossbeam-channel` or `tokio` for async, `log` + `env_logger`.
* **C/C++ side:** `stb_image.h`, `libgif` or `giflib`, `libpng`/`libjpeg` optional, use `asan/ubsan` in CI for memory checks.
* **Build:** `cc` crate for simple C compile, `cmake` crate if C++ heavy.

---

## 11. Documentation & CONTRIBUTING 

* Provide clear API docs for FFI functions (parameters, ownership, error codes).
* Add CONTRIBUTING.md explaining how to run tests, run fuzzers, and reproduce CI issues.
* Maintain CHANGELOG and semantic versioning.

---



---

## 12. Final Safety Checklist 

* All FFI functions must validate inputs and return explicit error codes.
* All heap allocations across FFI must have matching free function.
* Rust wrappers must never `panic!` across FFI boundary; instead return `Result`.
* Use bounded channels to prevent OOM.
* Run ASAN/UBSAN and fuzzing in CI.

---

